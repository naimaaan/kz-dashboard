import {
	BadRequestException,
	Injectable,
	NotFoundException,
	OnModuleInit,
} from '@nestjs/common'
import { spawn } from 'child_process'
import * as crypto from 'crypto'
import * as fs from 'fs'
import * as path from 'path'
import * as yaml from 'js-yaml'
import {
	ExploitDto,
	ExploitArgDto,
	ExploitRunResultDto,
	MitreAttackDto,
} from './exploit.dto'

interface YamlExploitArg {
	name: string
	default: string
}

interface YamlMitreAttack {
	tactic: string
	technique: string
}

interface YamlExploitEntry {
	id: string
	name: string
	script: string
	cve: string
	severity: string
	mitre_attack: YamlMitreAttack
	min_profile: string
	description: string
	args: YamlExploitArg[]
}

interface YamlExploitMetadata {
	service: string
	exploits: YamlExploitEntry[]
}

interface RunRecord {
	runId: string
	exploitId: string
	status: 'running' | 'success' | 'error' | 'timeout'
	output: string
	exitCode: number | null
	startedAt: Date
	finishedAt: Date | null
}

const RUN_TIMEOUT_MS = 60_000
const MAX_OUTPUT_BYTES = 64 * 1024
const MAX_STORED_RUNS = 100

@Injectable()
export class ExploitsService implements OnModuleInit {
	private readonly exploitsDir: string
	private catalog: Map<string, ExploitDto & { scriptPath: string }> = new Map()
	private runs: Map<string, RunRecord> = new Map()

	constructor() {
		this.exploitsDir =
			process.env.EXPLOITS_DIR ??
			path.resolve(process.cwd(), '..', 'exploits')
	}

	onModuleInit() {
		this.loadCatalog()
	}

	listExploits(): ExploitDto[] {
		return Array.from(this.catalog.values()).map(
			({ scriptPath: _, ...dto }) => dto,
		)
	}

	getExploit(id: string): ExploitDto {
		const entry = this.catalog.get(id)
		if (!entry) {
			throw new NotFoundException(`Exploit not found: ${id}`)
		}
		const { scriptPath: _, ...dto } = entry
		return dto
	}

	async runExploit(
		id: string,
		userArgs?: Record<string, string>,
	): Promise<ExploitRunResultDto> {
		const entry = this.catalog.get(id)
		if (!entry) {
			throw new NotFoundException(`Exploit not found: ${id}`)
		}

		if (!fs.existsSync(entry.scriptPath)) {
			throw new BadRequestException(
				`Script file missing: ${entry.scriptPath}`,
			)
		}

		const runId = crypto.randomUUID()
		const record: RunRecord = {
			runId,
			exploitId: id,
			status: 'running',
			output: '',
			exitCode: null,
			startedAt: new Date(),
			finishedAt: null,
		}
		this.runs.set(runId, record)
		this.trimOldRuns()

		const scriptArgs: string[] = []
		for (const argDef of entry.args) {
			const value = userArgs?.[argDef.name] ?? argDef.default
			if (/^[a-zA-Z0-9_.:\-\/]+$/.test(value)) {
				scriptArgs.push(value)
			} else {
				scriptArgs.push(argDef.default)
			}
		}

		return new Promise<ExploitRunResultDto>(resolve => {
			const proc = spawn('python3', [entry.scriptPath, ...scriptArgs], {
				cwd: path.dirname(entry.scriptPath),
				timeout: RUN_TIMEOUT_MS,
				env: { ...process.env, PYTHONUNBUFFERED: '1' },
			})

			const appendOutput = (chunk: Buffer) => {
				if (record.output.length < MAX_OUTPUT_BYTES) {
					record.output += chunk.toString('utf8')
				}
			}

			proc.stdout.on('data', appendOutput)
			proc.stderr.on('data', appendOutput)

			proc.on('close', (code, signal) => {
				record.exitCode = code
				record.finishedAt = new Date()

				if (signal === 'SIGTERM') {
					record.status = 'timeout'
					record.output += '\n[!] Process killed: execution timeout reached\n'
				} else if (code === 0) {
					record.status = 'success'
				} else {
					record.status = 'error'
				}

				resolve(this.toRunResult(record))
			})

			proc.on('error', err => {
				record.status = 'error'
				record.finishedAt = new Date()
				record.output += `\n[!] Process error: ${err.message}\n`
				resolve(this.toRunResult(record))
			})
		})
	}

	getRunOutput(runId: string): ExploitRunResultDto {
		const record = this.runs.get(runId)
		if (!record) {
			throw new NotFoundException(`Run not found: ${runId}`)
		}
		return this.toRunResult(record)
	}

	private loadCatalog(): void {
		this.catalog.clear()

		if (!fs.existsSync(this.exploitsDir)) {
			console.warn(`Exploits directory not found: ${this.exploitsDir}`)
			return
		}

		const entries = fs.readdirSync(this.exploitsDir, { withFileTypes: true })

		for (const entry of entries) {
			if (!entry.isDirectory()) continue

			const metaPath = path.join(this.exploitsDir, entry.name, 'metadata.yml')
			if (!fs.existsSync(metaPath)) continue

			try {
				const raw = fs.readFileSync(metaPath, 'utf8')
				const meta = yaml.load(raw) as YamlExploitMetadata

				for (const exploit of meta.exploits ?? []) {
					const scriptPath = path.join(
						this.exploitsDir,
						entry.name,
						exploit.script,
					)

					const args: ExploitArgDto[] = (exploit.args ?? []).map(a => ({
						name: a.name,
						default: a.default,
					}))

					const mitreAttack: MitreAttackDto = exploit.mitre_attack
						? {
								tactic: exploit.mitre_attack.tactic,
								technique: exploit.mitre_attack.technique,
							}
						: { tactic: 'Unknown', technique: 'Unknown' }

					this.catalog.set(exploit.id, {
						id: exploit.id,
						name: exploit.name,
						service: meta.service,
						script: exploit.script,
						cve: exploit.cve ?? '',
						severity: exploit.severity ?? 'unknown',
						mitreAttack,
						minProfile: exploit.min_profile ?? 'easy',
						description: (exploit.description ?? '').trim(),
						args,
						scriptPath,
					})
				}
			} catch (error) {
				console.error(
					`Failed to parse ${metaPath}:`,
					error instanceof Error ? error.message : error,
				)
			}
		}

		console.log(`Loaded ${this.catalog.size} exploits from ${this.exploitsDir}`)
	}

	private toRunResult(record: RunRecord): ExploitRunResultDto {
		const durationMs = record.finishedAt
			? record.finishedAt.getTime() - record.startedAt.getTime()
			: null

		return {
			runId: record.runId,
			exploitId: record.exploitId,
			status: record.status,
			output: record.output,
			exitCode: record.exitCode,
			startedAt: record.startedAt.toISOString(),
			finishedAt: record.finishedAt?.toISOString() ?? null,
			durationMs,
		}
	}

	private trimOldRuns(): void {
		if (this.runs.size <= MAX_STORED_RUNS) return

		const sorted = Array.from(this.runs.entries()).sort(
			([, a], [, b]) => a.startedAt.getTime() - b.startedAt.getTime(),
		)

		const toRemove = sorted.length - MAX_STORED_RUNS
		for (let i = 0; i < toRemove; i++) {
			this.runs.delete(sorted[i][0])
		}
	}
}
